#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp"},{"name":"fsharp","languageName":"fsharp"},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!fsharp

#load "util.fsx"
open Utils

let input = GetData 3 |> int
input

#!fsharp

/// Get the ring this number belongs to
let getRing =
    float 
    >> sqrt
    >> (+) -1.0
    >> (*) 0.5
    >> ceil
    >> int

let getPosition n =
    let ring = getRing n // also distance from corner to middle point
    let sideLength = 2 * ring + 1 // how far is it between each corner, including the corner 
    let endN = sideLength * sideLength // last number in ring, bottom right

    let period = ring * 2 // how far is it between each corner, excluding the corner
    
    let closestCorner = endN - ((endN - n) / period) * period // find the closest corner 
    let toMiddle = abs (ring + n - closestCorner) // How far from the middle
    let toCenter = ring

    toMiddle + toCenter

getPosition input

#!fsharp

type direction = Up | Down | Left | Right

let getDirection direction steps stepSequence =
    if steps = 0 then
        let steps = Seq.head stepSequence
        let stepSequence = Seq.tail stepSequence
        let direction = 
            match direction with
            | Up -> Left
            | Down -> Right
            | Left -> Down
            | Right -> Up
        direction, steps-1, stepSequence
    else
        direction, steps-1, stepSequence

let getNeighbourCells (x, y) grid =
    [(x-1, y-1); (x, y-1); (x+1, y-1);
     (x-1, y);           (x+1, y);
     (x-1, y+1); (x, y+1); (x+1, y+1)]
     |> List.choose (fun pos -> Map.tryFind pos grid)
     |> List.sum
     |> max 1

let rec step (x, y) direction steps stepSequence grid stoppingCondition =
        let direction, steps, stepSequence = getDirection direction steps stepSequence

        let number = getNeighbourCells (x, y) grid
        if number > stoppingCondition then number
        else 
            let grid = Map.add (x,y) (number) grid

            let pos = 
                match direction with
                | Up -> (x, y - 1)
                | Down -> (x, y + 1)
                | Left -> (x - 1, y)
                | Right -> (x + 1, y)

            step pos direction steps stepSequence grid stoppingCondition

let createGrid input =
    step (0, 0) Right 1 (Seq.initInfinite (fun i -> i / 2 + 1) |> Seq.skip 1) Map.empty input

createGrid 800

#!fsharp

createGrid input
